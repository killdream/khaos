-- Core interfaces
Interface Maybe 
:: a
 | Undefined


Interface Ordering
:: lower:   -Infinity .. -1
 | equal:   0
 | greater: 1 .. Infinity


Interface TimerID
:: platform dependant



-- Enables functional/higher-order function driven programming
Package functional

  -- Basic functional programming
  Module core
    -- Async
    delay :: Number, Fun -> TimerID
    defer :: Fun -> Undefined

    -- Wrapping
    compose      :: Fun... -> Fun
    uncurry      :: (Any... -> a) -> [Any] -> a
    uncurry_bind :: (<Any> Any... -> a) -> [Any, Any...] -> a
    curry        :: (Fun... -> a) -> Any -> ... -> a
    partial      :: (Fun... -> a), Pattern... -> Any... -> a

    -- Limiting
    limit :: (Fun -> a), Number -> Fun -> a
    once  :: (Fun -> a) -> Fun -> a
    until :: (Fun -> a), (Fun -> Bool) -> Fun -> a
    when  :: (Fun -> a), (Fun -> Bool) -> Fun -> a

    -- Lambda calculus
    identity :: a -> a
    constant :: a -> () -> a

    -- Predicate logic
    or  :: (Fun -> a)... -> Fun -> a
    and :: (Fun -> a)... -> Fun -> a
    not :: (Fun -> a) -> Fun -> Bool
  

  -- Dynamic multiple dispatching on Interfaces
  Module dispatch
    Object dispatching <| Base
      add!    :: @Dispatching, [Pattern...], Fun -> Fun
      remove! :: @Dispatching, [Pattern...] -> [Fun]
      resolve :: @Dispatching, Any... -> Fun
  

-- Object orientation routines
Package object

  -- Basic prototypal utilities
  Module core
    extend! :: target:Object, (Object | DataObject)... -> Object
    derive  :: proto:Object, (Object | DataObject)... -> Object

    Object Base
      make   :: @Base, Any... -> Object
      derive :: @Base, Any... -> Object
      

  -- Better multiple inheritance handling with some overhead
  Module traits
    -- :TODO:


-- Type checking facilities
Package types

  -- is-a relationship tests
  Module strict
    -- Base tests
    is? :: Any, Object | Fun -> Bool
    name :: Any -> String

    -- Specialised tests
    string?    :: Any -> Bool
    number?    :: Any -> Bool
    date?      :: Any -> Bool
    regexp?    :: Any -> Bool
    fun?       :: Any -> Bool
    bool?      :: Any -> Bool
    object?    :: Any -> Bool
    primitive? :: Any -> Bool
    undefined  :: Any -> Bool
    callable?  :: Any -> Bool


  -- Structural matching
  Module interface
    make     :: Object -> Interface
    matches? :: Interface, Object -> Bool


  -- First-class pattern matching
  Module pattern
    -- :TODO:
  
  

-- Collection handling API
Package collection

  -- Core generic iterators
  Module iterators
    -- :TODO:

    
  -- Lazy and generic operations on iterators
  Module lazy
    reduce :: Iterable, (acc:Any, val:e -> Any) -> Iterable
    map    :: Iterable, (e, k -> e) -> Iterable
    filter :: Iterable, (e, k -> Bool) -> Iterable
    every  :: Iterable, (e, k -> Bool) -> Iterable
    some   :: Iterable, (e, k -> Bool) -> Iterable
    

  -- Base sequence stuff
  Module sequence
    -- Iterating
    each :: [a], (e, UInt32, [a] -> Any) -> Undefined

    -- Building
    concatenate :: [a], [a] -> [a]
    
    -- Manipulating
    add!     :: [a], a -> [a]
    put!     :: [a], UInt32, a -> a
    remove!  :: [a], UInt32 -> a
    replace! :: [a], value:a, replacement:a -> [a]
    insert!  :: [a], UInt32, a -> [a]
    clear!   :: [a] -> [a]

    -- Inspecting
    at     :: [a], UInt32, default:a -> a
    at     :: [a], UInt32 -> Maybe a
    size   :: [a] -> UInt32
    count  :: [a], a -> UInt32
    empty? :: [a] -> Bool
    has?   :: [a], a -> Bool

    -- Slicing
    first    :: [a] -> Maybe a
    rest     :: [a] -> [a]
    last     :: [a] -> Maybe a
    but_last :: [a] -> [a]
    slice    :: [a], start:Int32, end:Int32 -> [a]
    slice    :: [a], start:Int32 -> [a]            # assumes end: size [a]
    slice    :: [a] -> [a]                         # assumes start: 0, end: size [a]
    take     :: [a], UInt32 -> [a]
    drop     :: [a], UInt32 -> [a]
    split    :: [a], (a, UInt32, [a] -> Bool) -> [[a]]

    -- Sorting
    sorted   :: [a], (a, a -> Ordering) -> [a]
    reversed :: [a] -> [a]

    -- Searching
    find      :: [a], (a, UInt32, [a] -> Bool) -> Maybe UInt32
    find_last :: [a], (a, UInt32, [a] -> Bool) -> Maybe UInt32
    

    -- Folding
    reduce       :: [a], initial:Any, (acc:Any, a -> Any) -> Any
    reduce       :: [a], (acc:Any, a -> Any) -> Any
    reduce_right :: [a], initial:Any, (acc:Any, a -> Any) -> Any
    reduce_right :: [a], (acc:Any, a -> Any) -> Any
    every        :: [a], (a, UInt32, [a] -> Bool) -> Bool
    some         :: [a], (a, UInt32, [a] -> Bool) -> Bool
    filter       :: [a], (a, UInt32, [a] -> Bool) -> [a]
    map          :: [a], (a, UInt32, [a] -> a) -> [a]

    

  Module set
    -- Iterating
    each :: {a}, (a, {a} -> Any) -> Undefined

    -- Manipulating
    add!     :: {a}, a -> {a}
    clear!   :: {a} -> {a}
    remove!  :: {a}, a -> {a}
    replace! :: {a}, value:a, replacement:a -> {a}

    -- Inspecting
    size   :: {a} -> Number
    count  :: {a}, a -> Number
    empty? :: {a} -> Bool
    has?   :: {a}, a -> Bool

    -- Folding
    reduce :: {a}, initial:Any, (acc:Any, a -> Any) -> Any
    reduce :: {a}, (acc:Any, a -> Any) -> Any
    every  :: {a}, (a, {a} -> Bool) -> Bool
    some   :: {a}, (a, {a} -> Bool) -> Bool
    filter :: {a}, (a, {a} -> Bool) -> {a}
    map    :: {a}, (a, {a} -> a) -> {a}

    -- Searching
    find :: {a}, (a, {a} -> Bool) -> Maybe a

    -- Set-level operations
    union        :: {a}, {a} -> {a}
    intersection :: {a}, {a} -> {a}
    difference   :: {a}, {a} -> {a}
    subset?      :: {a}, {a} -> Bool


  Module map
    -- Iterating
    each :: {k -> e}, (e, k, {k -> e}-> Any) -> Undefined

    -- Manipulating
    put!     :: {k -> e}, k, e -> {k -> e}
    remove!  :: {k -> e}, k -> {k -> e}
    replace! :: {k -> e}, value:e, replacement:e -> {k -> e}
    clear!   :: {k -> e} -> {k -> e}

    -- Inspecting
    at       :: {k -> e}, k, default:e -> e
    at       :: {k -> e}, k -> Maybe e
    size     :: {k -> e} -> Number
    count    :: {k -> e}, e -> Number
    empty?   :: {k -> e} -> Bool
    has_key? :: {k -> e}, k -> Bool

    -- Decomposing
    keys   :: {k -> e} -> [k]
    values :: {k -> e} -> [e]
    items  :: {k -> e} -> [(k, e)]

    -- Searching
    find :: {k -> e}, (e, k, {k -> e} -> Bool) -> Maybe k

    -- Folding
    reduce :: {k -> e}, initial:Any, (acc:Any, e, k -> Any) -> Any
    reduce :: {k -> e}, (acc:Any, e, k -> Any) -> Any
    every  :: {k -> e}, (e, k, {k -> e} -> Bool) -> Bool
    some   :: {k -> e}, (e, k, {k -> e} -> Bool) -> Bool
    filter :: {k -> e}, (e, k, {k -> e} -> Bool) -> {k -> e}
    map    :: {k -> e}, (e, k, {k -> e} -> e) -> {k -> e}
    

  Module dictionary
    Object dictionary <| Object, {Any -> Any}


  Module string
    -- Building
    repeat      :: String, Number -> String
    concatenate :: String... -> String

    -- 
    trim        :: String -> String
    trim_left   :: String -> String
    trim_right  :: String -> String

    -- Inspecting
    starts_with? :: String, String -> Bool
    ends_with?   :: String, String -> Bool
    has?         :: String, String -> String
    count        :: String, String -> String

    -- Case folding / mappings
    upcase     :: String -> String
    downcase   :: String -> String
    capitalise :: String, all_words:Bool -> String
    dasherise  :: String -> String
    camelise   :: String -> String

    -- Searching
    find      :: String, (String, Number, String -> Bool) -> Maybe Number
    find_last :: String, (String, Number, String -> Bool) -> Maybe Number

    -- Slicing
    first    :: String -> Maybe Char
    rest     :: String -> String
    last     :: String -> Maybe Char
    but_last :: String -> String
    slice    :: String, Number, Number -> String
    slice    :: String, Number -> String
    slice    :: String -> String
    take     :: String, Number -> String
    drop     :: String, Number -> String
    split    :: String, String, Number -> [String]

    -- Comparison
    compare :: String, String, foldcase:Bool -> Ordering
    equal_p :: String, String, foldcase:Bool -> Bool

    -- Formatting
    format :: String, {String -> String | (String... -> String)} -> String
    

-- Control flow structures
Package flow-control

  -- Promises
  Module promise
    bind          :: @this:Promise, Any... -> this
    fail          :: @this:Promise, Any... -> this
    timeout       :: @this:Promise, Number -> this
    clear_timeout :: @this:Promise -> this
    when          :: @this:Promise, String, Fun -> this
    then          :: @this:Promise, Fun -> this
    ok            :: @this:Promise, Fun -> this
    failed        :: @this:Promise, Fun -> this
    timeouted     :: @this:Promise, Fun -> this


  -- Event-driven programming
  Module events
    Object event
      handle :: @this:Event -> this
      halt   :: @this:Event -> this
      bubble :: @this:Event -> this

    Object handler
      exec :: Event, Any... -> Any
      
  
    Object eventful
      on!     :: @Eventful, String, Fun -> Handler
      once!   :: @Eventful, String, Fun -> Handler
      trigger :: @Eventful, String, Any... -> Event
      remove! :: @Eventful, String, Handler -> [Handler]  # fine-grained
      remove! :: @Eventful, String -> [Handler]           # all handlers for event
      remove! :: @Eventful, Handler -> [Handler]          # handler from all events
      clear!  :: @Eventful, -> [Handler]


  -- Model basis
  Module observable
    Object observable <| Eventful
      get :: @Observable, String -> a
      set :: @Observable, String, a -> a
      tap :: @Observable, String, Fun -> Handler